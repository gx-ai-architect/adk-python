{"task_description":"Translate complex Python code to Java code.","seed_question":"Translate Python's recursive Fibonacci function with memoization to Java.","seed_response":"import java.util.HashMap;\n\npublic class Fibonacci {\n    private HashMap<Integer, Integer> memo = new HashMap<>();\n\n    public int fib(int n) {\n        if (n <= 1) {\n            return n;\n        }\n        if (memo.containsKey(n)) {\n            return memo.get(n);\n        }\n        int result = fib(n - 1) + fib(n - 2);\n        memo.put(n, result);\n        return result;\n    }\n}","output":"Here's a question and answer pair for translating complex Python code to Java code:\n\nQ: Convert the following Python code that implements a binary search algorithm to its equivalent Java code, ensuring that the Java implementation maintains the same level of efficiency and readability as the original Python code.\n```python\ndef binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) \/\/ 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n```\n\nA: The Java equivalent of the provided Python binary search algorithm can be implemented as follows:\n```java\npublic class BinarySearch {\n    public static int binarySearch(int[] arr, int target) {\n        int left = 0;\n        int right = arr.length - 1;\n        while (left <= right) {\n            int mid = left + (right - left) \/ 2;\n            if (arr[mid] == target) {\n                return mid;\n            } else if (arr[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int[] array = {2, 5, 8, 12, 16, 23, 38, 56, 72, 91};\n        int targetValue = 23;\n        int result = binarySearch(array, targetValue);\n        if (result == -1) {\n            System.out.println(\"Element not present in the array\");\n        } else {\n            System.out.println(\"Element found at index \" + result);\n        }\n    }\n}\n```\nThis Java implementation maintains the same efficiency as the Python code, with a time complexity of O(log n), where n is the number of elements in the array. It also ensures readability by using clear variable names and concise logic. The example usage in the `main` method demonstrates how to use the `binarySearch` method with a sample array and target value."}
{"task_description":"Translate complex Python code to Java code.","seed_question":"Translate Python's handling of JSON using `json` library to Java using `Gson` library.","seed_response":"import com.google.gson.Gson;\nimport com.google.gson.JsonObject;\n\npublic class JsonExample {\n    public static void main(String[] args) {\n        Gson gson = new Gson();\n        String jsonString = \"{\\\"name\\\":\\\"John\\\",\\\"age\\\":30}\";\n        JsonObject jsonObject = gson.fromJson(jsonString, JsonObject.class);\n        System.out.println(jsonObject.get(\"name\").getAsString());\n    }\n}","output":"Here's a question and answer pair to translate complex Python code to Java code:\n\n**Question:** How would you replicate Python's implementation of a decorator to measure execution time using the `time` module and `functools` library in Java, utilizing the `java.lang.System` class and Java 8's functional programming features?\n\n**Answer:** To achieve this in Java, you can leverage the `java.lang.System` class for timing and Java 8's functional programming features. You would create a functional interface for the decorator, use a lambda expression to wrap the original method, and measure the execution time using `System.nanoTime()` before and after calling the original method. Here's an example implementation:\n```java\nimport java.lang.System;\nimport java.util.function.Supplier;\n\npublic class TimingDecorator {\n    public static <T> Supplier<T> timed(Supplier<T> originalMethod) {\n        return () -> {\n            long startTime = System.nanoTime();\n            T result = originalMethod.get();\n            long endTime = System.nanoTime();\n            System.out.println(\"Execution time: \" + (endTime - startTime) + \" nanoseconds\");\n            return result;\n        };\n    }\n\n    public static void main(String[] args) {\n        Supplier<String> exampleMethod = () -> {\n            try {\n                Thread.sleep(1000); \/\/ Simulate some work\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n            return \"Result\";\n        };\n\n        Supplier<String> timedMethod = timed(exampleMethod);\n        String result = timedMethod.get();\n        System.out.println(\"Result: \" + result);\n    }\n}\n```\nThis Java implementation uses a `Supplier` interface to represent the original method and returns a new `Supplier` that wraps the original method, measuring the execution time and printing it to the console. The `main` method demonstrates how to use this decorator with an example method that simulates some work by sleeping for 1 second."}
{"task_description":"Translate complex Python code to Java code.","seed_question":"Translate Python's threading example with locking to Java using `ExecutorService` and `ReentrantLock`.","seed_response":"import java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class ThreadExample {\n    private final ReentrantLock lock = new ReentrantLock();\n    private int count = 0;\n\n    public void increment() {\n        lock.lock();\n        try {\n            count++;\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public static void main(String[] args) {\n        ThreadExample example = new ThreadExample();\n        ExecutorService executor = Executors.newFixedThreadPool(2);\n        for (int i = 0; i < 1000; i++) {\n            executor.submit(example::increment);\n        }\n        executor.shutdown();\n        while (!executor.isTerminated()) {}\n        System.out.println(example.count);\n    }\n}","output":"Here's a question and answer pair to translate complex Python code to Java code:\n\n**Q: Convert the Python code that utilizes a decorator to implement a singleton pattern into equivalent Java code using double-checked locking for synchronization.**\n**A:** To achieve this, we first need to understand the Python code that uses a decorator to implement the singleton pattern. A typical Python implementation would look something like this:\n```python\ndef singleton(class_):\n    instances = dict()\n    def wrap(*args, **kwargs):\n        if class_ not in instances:\n            instances[class_] = class_(*args, **kwargs)\n        return instances[class_]\n    return wrap\n\n@singleton\nclass SingletonClass:\n    def __init__(self, value):\n        self.value = value\n\n    def get_value(self):\n        return self.value\n```\nNow, let's translate this into Java using double-checked locking for synchronization. Java does not support decorators like Python, so we will implement the singleton pattern directly into the class. Here's how you can do it:\n```java\npublic class SingletonClass {\n    private volatile static SingletonClass instance;\n    private String value;\n\n    private SingletonClass(String value) {\n        this.value = value;\n    }\n\n    public static SingletonClass getInstance(String value) {\n        if (instance == null) { \/\/ first check\n            synchronized (SingletonClass.class) {\n                if (instance == null) { \/\/ double check\n                    instance = new SingletonClass(value);\n                }\n            }\n        }\n        return instance;\n    }\n\n    public String getValue() {\n        return value;\n    }\n}\n```\nHowever, the above Java code does not perfectly translate the Python decorator's functionality because Java's static initialization is thread-safe, and we typically don't pass arguments to the singleton instance in Java. A more common Java singleton pattern without arguments would look like this:\n```java\npublic class SingletonClass {\n    private volatile static SingletonClass instance;\n\n    private SingletonClass() {}\n\n    public static SingletonClass getInstance() {\n        if (instance == null) { \/\/ first check\n            synchronized (SingletonClass.class) {\n                if (instance == null) { \/\/ double check\n                    instance = new SingletonClass();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\nThis Java version ensures that only one instance of `SingletonClass` is created, even in a multi-threaded environment, using double-checked locking for efficiency."}
{"task_description":"Translate complex Python code to Java code.","seed_question":"Translate Python's async web request using `aiohttp` to Java using `HttpClient`.","seed_response":"import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\n\npublic class AsyncExample {\n    public static void main(String[] args) throws Exception {\n        HttpClient client = HttpClient.newHttpClient();\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(\"https:\/\/api.example.com\/data\"))\n                .build();\n\n        client.sendAsync(request, HttpResponse.BodyHandlers.ofString())\n                .thenApply(HttpResponse::body)\n                .thenAccept(System.out::println)\n                .join();\n    }\n}","output":"Here's a question and answer pair to translate complex Python code to Java code:\n\nQ: How would you convert Python's asynchronous HTTP request handling using `asyncio` and `aiohttp` libraries to achieve the same functionality in Java, utilizing the `CompletableFuture` class to handle asynchronous operations and the `HttpClient` class for sending HTTP requests?\nA: To accomplish this, you would first create an instance of the `HttpClient` class, then construct an `HttpRequest` object specifying the request method, URI, and any necessary headers or body. The `sendAsync` method of the `HttpClient` instance would be used to send the request asynchronously, returning a `CompletableFuture` that, when completed, provides the `HttpResponse`. You can then use the `thenApply` and `thenAccept` methods to handle the response body and print it to the console, respectively, similar to the example provided earlier. This approach allows for non-blocking I\/O operations, enabling your program to perform other tasks while waiting for the HTTP request to complete. \n\nHere's a sample Java code snippet demonstrating this:\n```java\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.concurrent.CompletableFuture;\n\npublic class AsyncRequestExample {\n    public static void main(String[] args) {\n        HttpClient client = HttpClient.newHttpClient();\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(\"https:\/\/api.example.com\/data\"))\n                .GET()\n                .build();\n\n        CompletableFuture<HttpResponse<String>> responseFuture = client.sendAsync(request, HttpResponse.BodyHandlers.ofString());\n        responseFuture.thenApply(HttpResponse::body)\n                .thenAccept(System.out::println)\n                .join();\n    }\n}\n```"}
{"task_description":"Translate complex Python code to Java code.","seed_question":"Translate Python's data manipulation using Pandas to Java using Apache POI.","seed_response":"import org.apache.poi.ss.usermodel.*;\nimport org.apache.poi.xssf.usermodel.XSSFWorkbook;\n\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Iterator;\n\npublic class ExcelExample {\n    public static void main(String[] args) throws IOException {\n        FileInputStream file = new FileInputStream(\"example.xlsx\");\n        Workbook workbook = new XSSFWorkbook(file);\n        Sheet sheet = workbook.getSheetAt(0);\n        Iterator<Row> rowIterator = sheet.iterator();\n        while (rowIterator.hasNext()) {\n            Row row = rowIterator.next();\n            Iterator<Cell> cellIterator = row.cellIterator();\n            while (cellIterator.hasNext()) {\n                Cell cell = cellIterator.next();\n                switch (cell.getCellType()) {\n                    case STRING: System.out.print(cell.getStringCellValue() + \"\t\"); break;\n                    case NUMERIC: System.out.print(cell.getNumericCellValue() + \"\t\"); break;\n                    default: System.out.print(\"\t\"); break;\n                }\n            }\n            System.out.println();\n        }\n        file.close();\n        FileOutputStream outFile =new FileOutputStream(\"updated_example.xlsx\");\n        workbook.write(outFile);\n        outFile.close();\n    }\n}","output":"Here's a question and answer pair to translate complex Python code to Java code:\n\n**Q: How would you replicate the functionality of Python's NumPy library for matrix operations in Java, and what libraries or frameworks would you utilize to achieve this?**\n\n**A:** To replicate the functionality of Python's NumPy library for matrix operations in Java, you can utilize libraries such as Apache Commons Math or ojAlgo. These libraries provide efficient and robust implementations of various mathematical and statistical operations, including matrix operations. For example, Apache Commons Math provides classes like `RealMatrix` and `Array2DRowRealMatrix` to represent and manipulate matrices, while ojAlgo provides a `BasicMatrix` class for similar purposes. You can use these libraries to perform operations like matrix addition, multiplication, inversion, and more. Here's a sample code snippet using Apache Commons Math:\n```java\nimport org.apache.commons.math3.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math3.linear.RealMatrix;\n\npublic class MatrixExample {\n    public static void main(String[] args) {\n        double[][] data = {{1, 2}, {3, 4}};\n        RealMatrix matrix = new Array2DRowRealMatrix(data);\n        RealMatrix inverse = matrix.inverse();\n        System.out.println(inverse);\n    }\n}\n```\nThis code creates a 2x2 matrix, inverts it, and prints the result, demonstrating the matrix operation capabilities of Apache Commons Math. By leveraging these libraries, you can achieve NumPy-like functionality in Java for matrix operations and other numerical computations."}
